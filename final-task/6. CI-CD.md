```
CI/CD with Jenkins
Instructions

[ CI/CD ]

Using Jenkins, create a pipeline running:
Repository pull
Image build
Testing Your Code
Push Image into your own docker registry private
SSH into your server
Pull image from docker registry private
Redeploy your deployment apps
For testing Stage, u must use sonarqube for testing your code quality
```


# PostgreSQL

- Buat database untuk SonarQube, jangan lupa buat volume
![image](https://github.com/user-attachments/assets/a03922b7-1fd4-4ad2-a09d-92d318526746)


![image](https://github.com/user-attachments/assets/589625ea-6d41-4aa1-a3ba-597f8f0c85a3)

# Sonarqube

![image](https://github.com/user-attachments/assets/d0285a13-5e0c-40ac-95cf-fdc7f714222b)

# Jenkins

- Saya setup jenkins dengan bantuan Ansible

```yaml
    - name: Create a Docker network for Jenkins and SonarQube
      docker_network:
        name: cicd_network
        state: present

    - name: Deploy PostgreSQL container for SonarQube
      docker_container:
        name: sonarqube_postgresql
        image: postgres:13
        env:
          POSTGRES_DB: "{{ db_name }}"
          POSTGRES_USER: "{{ db_user }}"
          POSTGRES_PASSWORD: "{{ db_password }}"
        volumes:
          - /var/lib/postgresql/data:/var/lib/postgresql/data
        networks:
          - name: cicd_network
        ports:
          - "5432:5432"
        state: started
        restart_policy: always

    - name: Wait for PostgreSQL to be ready
      wait_for:
        host: "127.0.0.1"
        port: 5432
        timeout: 30

    - name: Deploy SonarQube container
      docker_container:
        name: sonarqube
        image: "sonarqube:{{ sonarqube_version }}"
        env:
          SONAR_JDBC_URL: "jdbc:postgresql://sonarqube_postgresql:5432/{{ db_name }}"
          SONAR_JDBC_USERNAME: "{{ db_user }}"
          SONAR_JDBC_PASSWORD: "{{ db_password }}"
          SONAR_SEARCH_JAVAOPTS: "-Xms512m -Xmx512m"
        volumes:
          - sonarqube_data:/opt/sonarqube/data
          - sonarqube_extensions:/opt/sonarqube/extensions
          - sonarqube_logs:/opt/sonarqube/logs
        networks:
          - name: cicd_network
        ports:
          - "{{ sonarqube_port }}:9000"
        state: started
        restart_policy: always

    - name: Deploy Jenkins container
      docker_container:
        name: jenkins
        image: jenkins/jenkins:lts
        user: root
        volumes:
          - /var/jenkins_home:/var/jenkins_home
          - /var/run/docker.sock:/var/run/docker.sock
        networks:
          - name: cicd_network
        ports:
          - "{{ jenkins_port }}:8080"
        state: started
        restart_policy: always
```
- Setelah menjalankan Ansible, Login terlebih dahulu
Jenkins akan menampung password default di
`/var/jenkins_home/secrets/initialAdminPassword`
![image](https://github.com/user-attachments/assets/661a94b0-13cd-4678-8d52-5b620ba769a5)


![image](https://github.com/user-attachments/assets/36a86a4a-0570-4bb5-bae5-666d54f1a0d4)


- Install Plugins yang dibutuhkan seperti ssh-agents, sonarqube-scanner, docker pipeline, dan sebagainya tergantung pada kebutuhan kita nantinya

![image](https://github.com/user-attachments/assets/e0a4dff7-edb6-4b50-8220-8f8956e29baf)

- Manage credentials yang dibutuhkan seperti `github`, `ssh-key`, `sonarqube-token`

![image](https://github.com/user-attachments/assets/f701179a-c665-440a-b230-bf08ae6a0ca8)

- Buat pipeline dan masukkan github credentials yang kita buat tadi untuk mengakses repository kita

Buat jenkinsfile di repository kita

# STAGING Env

```jenkins
pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "${REGISTRY_URL}/${BE_NAME_BUILD}:v4"
        TEST_PORT = 5050
        GIT_BRANCH = 'staging'
    }

    stages {
        stage('Git Pull on App Server') {
            steps {
                script {
                    sshagent(credentials: [SSH_STAGING_CREDENTIALS]) {
                        sh """
                        ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} ${STAGING_SERVER} '
                            cd ${BE_STAGE_DIR} &&
                            git checkout ${GIT_BRANCH} &&
                            git pull origin ${GIT_BRANCH}
                        '
                        """
                    }
                }
            }
        }
        
        stage('Checkout & SonarQube Analysis') {
            parallel {
                stage('Checkout from GitHub') {
                    steps {
                        script {
                            git branch: "${GIT_BRANCH}", url: "${GIT_BE_URL}", credentialsId: "github-credentials"
                        }
                    }
                }
                
                stage('SonarQube Analysis') {
                    steps {
                        withSonarQubeEnv('SonarQube') {
                            script {
                                def scannerHome = tool 'SonarQube Scanner'
                                sh """
                                ${scannerHome}/bin/sonar-scanner \
                                    -Dsonar.projectKey=be-dumbmerch-staging \
                                    -Dsonar.projectName=be-dumbmerch-staging \
                                    -Dsonar.sources=. \
                                    -Dsonar.java.binaries=target
                                """
                            }
                        }
                    }
                }
            }
        }

        stage('Trivy Scan') {
            steps {
                script {
                    // Run Trivy scan on the Docker image
                    sh "trivy fs --severity HIGH,CRITICAL,MEDIUM ."
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh """
                    docker build --no-cache --cache-from=${DOCKER_IMAGE} -t ${DOCKER_IMAGE} .
                    """
                }
            }
        }

        stage('Trivy Scan Docker Image') {
            steps {
                script {
                    sh "trivy image --severity HIGH,CRITICAL ${DOCKER_IMAGE}"
                }
            }
        }

        stage('Push Docker Image to Registry') {
            steps {
                script {
                    sh "docker push ${DOCKER_IMAGE}"
                }
            }
        }

        stage('Run Container and Wget Check on App Server') {
            steps {
                script {
                    sshagent(credentials: [SSH_STAGING_CREDENTIALS]) {
                        def result = sh(
                            script: """
                            ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} ${STAGING_SERVER} '
                            
                                docker run --rm --name ${TEST_BE_CONTAINER} --network apps_network -d -p ${TEST_PORT}:${BE_APP_PORT} ${DOCKER_IMAGE}
                                sleep 10

                                if wget --spider -q --server-response http://127.0.0.1:${TEST_PORT}/ 2>&1 | grep "404 Not Found"; then
                                    echo "Wget spider success"
                                else
                                    echo "Unexpected response or webserver not reachable, stopping the process."
                                    exit 1
                                fi

                                docker stop ${TEST_BE_CONTAINER}
                            '
                            """,
                            returnStatus: true
                        )

                        if (result != 0) {
                            error("Container run or wget check failed.")
                        }
                    }
                }
            }
        }

        stage('Deploy using Docker Compose') {
            steps {
                script {
                    sshagent(credentials: [SSH_STAGING_CREDENTIALS]) {
                        sh """
                        ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} ${STAGING_SERVER} '
                            cd ${STAGE_DIR} &&
                            sed -i "s|image:.*${BE_NAME_BUILD}:.*|image: ${DOCKER_IMAGE}|" compose.yaml &&
                            docker compose down backend &&
                            docker compose up -d
                        '
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
```


- Sonarqube Scanner

![image](https://github.com/user-attachments/assets/859a80fa-bd79-4f03-92fa-71952161818a)

![image](https://github.com/user-attachments/assets/643257a7-2c1b-46aa-94c5-beb2ae9542e0)

- Trivy

![image](https://github.com/user-attachments/assets/795588db-efb4-49d9-86ff-a1115d7e79e0)

- Pipeline Staging

### CI
```
1. Git pull di server 
2. Checkout SCM & Sonarqube Analysis
3. Trivy Code Scan
4. Build Docker Image
5. Trivy Scan Docker Image
6. Push Docker Image ke Private Registry
7. Running Docker Container & Wget Testing
```

### CD
```
8. Deployment using Docker Compose
```
![image](https://github.com/user-attachments/assets/9b525a70-ab08-4711-a35a-75453970d938)

# PRODUCTION Env (W/ Argo CD)

```Jenkinsfile
pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "${REGISTRY_URL}/${BE_NAME_BUILD}:latest"
        GIT_BRANCH = 'production'
    }

    stages {
        stage('Git Pull on App Server') {
            steps {
                script {
                    sshagent(credentials: [SSH_CREDENTIALS]) {
                        sh """
                        ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} ${SERVER} '
                            cd ${BE_STAGE_DIR} &&
                            git checkout ${GIT_BRANCH} &&
                            git pull origin ${GIT_BRANCH}
                        '
                        """
                    }
                }
            }
        }

        stage('Checkout from GitHub') {
            steps {
                script {
                    git branch: "${GIT_BRANCH}", url: "${GIT_BE_URL}", credentialsId: "github-credentials"
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    sh """
                    docker build --no-cache --cache-from=${DOCKER_IMAGE} -t ${DOCKER_IMAGE} .
                    """
                }
            }
        }

        stage('Trivy Scan Docker Image') {
            steps {
                script {
                    sh "trivy image --severity HIGH,CRITICAL,MEDIUM ${DOCKER_IMAGE}"
                }
            }
        }

        stage('Push Docker Image to Registry') {
            steps {
                script {
                    sh "docker push ${DOCKER_IMAGE}"
                }
            }
        }

        stage('Update Kubernetes Manifest') {
            steps {
                script {
                    sshagent(credentials: [SSH_CREDENTIALS]) {
                        sh """
                        ssh -o StrictHostKeyChecking=no -p ${SSH_PORT} ${SERVER} '
                            cd ${MANIFEST_BE_DIR} &&
                            sed -i "s|image:.*|image: ${DOCKER_IMAGE}|" backend.yaml &&
                            git add backend.yaml
        
                            # Periksa ada perubahan atau tidak
                            if ! git diff-index --quiet HEAD; then
                                git commit -m "Update backend image to ${DOCKER_IMAGE}" &&
                                git push origin ${GIT_BRANCH}
                            else
                                echo "No changes to commit."
                            fi
                        '
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs()
        }
    }
}
```

- Pipeline Production

![image](https://github.com/user-attachments/assets/7260cf22-1304-4247-b104-461a947a12d4)


Dalam Environment Production, Jenkins hanya sampai Continuous Integrations(CI). Untuk CD nya sendiri saya memakai Argo CD. 
ArgoCD harus diinstall terlebih dahulu di kubernetes cluster kita.

```
# Manifest
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl get pods -n argocd

# Helm
helm repo add argo https://argoproj.github.io/argo-helm
helm repo update

helm install argocd argo/argo-cd -n argocd
```

![image](https://github.com/user-attachments/assets/64195dd2-e6f7-4c52-836e-aeea7fea926d)

- Buat Ingress untuk ArgoCD

![image](https://github.com/user-attachments/assets/78190041-5686-4de2-9199-56ba987ed731)

- Masuk ke Website ArgoCD

![image](https://github.com/user-attachments/assets/594afcf1-1dd1-476c-8fe7-d116b416f068)

- Connect Repository FE&BE

![image](https://github.com/user-attachments/assets/c8354b0e-ba6a-4aea-8b27-3abc6b771aa7)

- Buat file manifest di repository

![image](https://github.com/user-attachments/assets/b7c2e200-cd79-4ff7-86b1-578948ef3a13)

- Buat Deployment di Argo CD

![image](https://github.com/user-attachments/assets/b58e473a-6278-41c8-979f-fc4b9afee613)

![image](https://github.com/user-attachments/assets/151c2156-303c-4bce-a551-fda43b54efaf)



